function simulate_part1()
% Part 1: Single SV vs single *stationary* OV
% Implements: CRPF, VO check, DWA-style feasible velocity search,
% plots (CRPF heatmap+contours+trajectory, timeseries, VO diagnostic),
% and CSV logs (summary + trajectory).
%
% Usage:
%   simulate_part1

rng(0);  % reproducibility
OUT = "outputs_part1";
if ~exist(OUT,"dir"), mkdir(OUT); end

%% --- Config / scenario
dt = 0.1;          % [s]
T  = 60.0;         % [s]
N  = round(T/dt);

% Lane (straight along +Y)
lane_center_x = 0.0;
lane_half_width = 4.0;
road_left  = lane_center_x + lane_half_width;
road_right = lane_center_x - lane_half_width;

% Vehicle radii (disc approx)
rS = 1.0; rO = 1.0; Rsum = rS + rO;

road_left_vehicle_safety_limit = road_left + rS;
road_right_vehicle_safety_limit = road_right - rs


% SV init
sv_x = 0.0; sv_y = -40.0;
sv_v = 12.0;
sv_theta = deg2rad(90.0);

% SV limits
a_min = -4.0; a_max = 2.5;     % accel [m/s^2]
omega_min = -0.6; omega_max = 0.6;  % yaw rate command [rad/s]
v_min = 5.0; v_max = 25.0;
v_des = 15.0;

% OV (stationary) at origin
ov_x = 0.0; ov_y = 0.0;
ov_vx = 0.0; ov_vy = 0.0;
ov_ax = 0.0; ov_ay = 0.0;
m_O = 1500.0; size_O = 4.5; kappa_O = 1.0;

% CRPF tuning
CRPF_G = 1.0; CRPF_ZETA = 2.0;
PSEUDO_EPS = 1.2; PSEUDO_RHO = 0.02;

%% --- Precompute CRPF field for visualization
gx = linspace(-12,12,121);
gy = linspace(-100,120,141);
CR = zeros(numel(gy), numel(gx));
for j = 1:numel(gy)
    for i = 1:numel(gx)
        CR(j,i) = crpf(gx(i), gy(j), ov_x, ov_y, 0.0, 0,0, m_O, size_O, kappa_O, CRPF_G, CRPF_ZETA, PSEUDO_EPS, PSEUDO_RHO);
    end
end

%% --- Simulation loop
log = struct('t',[],'sv_x',[],'sv_y',[],'sv_v',[],'sv_theta',[], ...
             'dist_to_obs',[],'risk',[],'ttc',[],'picked_v',[],'picked_omega',[]);
collision = false; min_ttc = inf; min_dist = inf;

for k = 1:N
    t = (k-1)*dt;

    p_rel = [sv_x-ov_x, sv_y-ov_y];
    v_rel = [sv_v*cos(sv_theta)-ov_vx, sv_v*sin(sv_theta)-ov_vy];
    dist  = norm(p_rel);

    risk_now = crpf(sv_x, sv_y, ov_x, ov_y, 0.0, 0,0, m_O, size_O, kappa_O, CRPF_G, CRPF_ZETA, PSEUDO_EPS, PSEUDO_RHO);
    [~, ttc] = will_collide(p_rel, v_rel, Rsum, 8.0);
    min_ttc = min(min_ttc, ttc);
    min_dist = min(min_dist, dist);

    % --- DWA candidates
    a_samples = linspace(a_min, a_max, 7);
    omega_samples = linspace(omega_min, omega_max, 9);

    best_cost = inf; best_v_next = sv_v; best_theta_next = sv_theta;
    for a_cmd = a_samples
        v_next = min(max(sv_v + a_cmd*dt, v_min), v_max);
        for d_omega = omega_samples
            theta_next = sv_theta + d_omega*dt;

            % short rollout 1s
            x_tmp = sv_x; y_tmp = sv_y; th = theta_next; vtmp = v_next;
            ok = true; acc_risk = 0;
            for s = 1:10
                x_tmp = x_tmp + vtmp*cos(th)*dt;
                y_tmp = y_tmp + vtmp*sin(th)*dt;

                if ~(in_lane(x_tmp, road_right, road_left)), ok=false; break; end
                if hypot(x_tmp-ov_x,y_tmp-ov_y) <= Rsum, ok=false; break; end
                rr = crpf(x_tmp, y_tmp, ov_x, ov_y, 0.0, 0,0, m_O, size_O, kappa_O, CRPF_G, CRPF_ZETA, PSEUDO_EPS, PSEUDO_RHO);
                acc_risk = acc_risk + rr;
            end
            if ~ok, continue; end

            cost = 1.0*acc_risk + 0.1*(v_des - v_next)^2 + 0.05*(d_omega^2);
            if cost < best_cost
                best_cost = cost; best_v_next = v_next; best_theta_next = theta_next;
            end
        end
    end

    if ~isfinite(best_cost)
        best_v_next = max(sv_v, v_min);
        best_theta_next = sv_theta;
    end

    % Apply
    sv_v = best_v_next;
    sv_theta = wrapToPi(best_theta_next);
    sv_x = sv_x + sv_v*cos(sv_theta)*dt;
    sv_y = sv_y + sv_v*sin(sv_theta)*dt;

    % Log
    log.t(end+1,1) = t;
    log.sv_x(end+1,1) = sv_x; log.sv_y(end+1,1) = sv_y;
    log.sv_v(end+1,1) = sv_v; log.sv_theta(end+1,1) = sv_theta;
    log.dist_to_obs(end+1,1) = dist; log.risk(end+1,1) = risk_now;
    log.ttc(end+1,1) = ttc; log.picked_v(end+1,1) = sv_v; log.picked_omega(end+1,1) = 0;

    if dist <= Rsum, collision = true; break; end
end

TBL = struct2table(log);
writetable(TBL, fullfile(OUT,"trajectory_part1.csv"));

summary = table(collision, min_dist, min_ttc, TBL.sv_x(end), TBL.sv_y(end), TBL.sv_v(end), height(TBL), ...
    'VariableNames', {'CollisionOccurred','MinDistance_m','MinTTC_s','FinalXPos_m','FinalYPos_m','FinalSpeed_mps','StepsSimulated'});
writetable(summary, fullfile(OUT,"summary_part1.csv"));

%% --- Plots
% A) CRPF heatmap + contours + trajectory
% === CRPF heatmap + contours + trajectory (fixed window around OV) ===
figure('Color','w');
imagesc(gx, gy, log10(CR+1e-9)); axis xy; hold on; colorbar;
title('CRPF Heatmap (Stationary OV) + SV Trajectory'); xlabel('X [m]'); ylabel('Y [m]');

% contours (no alpha)
[~, hC] = contour(gx, gy, log10(CR+1e-9), 10, 'LineWidth', 0.6);
set(hC, 'LineColor', [1 1 1]*0.9);

% lane boundaries (thick dotted)
xline(road_left,  'k:', 'LineWidth', 2.0);
xline(road_right, 'k:', 'LineWidth', 2.0);

scatter(ov_x, ov_y, 20, 'r', 'filled', 'MarkerEdgeColor','k', ...
        'DisplayName','Obstacle (center)');
% plot SV path but CLIP the axes to the CRPF window
plot(TBL.sv_x, TBL.sv_y, 'r-', 'LineWidth', 2);           % red trajectory
scatter(TBL.sv_x(1),  TBL.sv_y(1),  50, 'go','filled');   % start (blue)
scatter(TBL.sv_x(end),TBL.sv_y(end),50, 'go','filled');   % end (red)

% keep axes locked to the CRPF grid so it doesn't stretch
xlim([gx(1) gx(end)]);
ylim([-50 50]);
grid on;

% B) Time series
figure('Color','w');
subplot(3,1,1); plot(TBL.t, TBL.sv_v); ylabel('Speed [m/s]'); grid on;
subplot(3,1,2); plot(TBL.t, TBL.dist_to_obs); hold on; yline(Rsum,'r--'); ylabel('Dist to OV [m]'); grid on;
subplot(3,1,3); plot(TBL.t, TBL.risk); ylabel('CRPF'); xlabel('Time [s]'); grid on;
exportgraphics(gcf, fullfile(OUT,"fig_timeseries.png"), 'Resolution',160);

% C) VO diagnostic at t=0
V = linspace(-20,20,81); U = linspace(-20,20,81);
unsafe = false(numel(U), numel(V));
p0 = [TBL.sv_x(1)-ov_x, TBL.sv_y(1)-ov_y];
for i = 1:numel(U)
    for j = 1:numel(V)
        [collide,~] = will_collide(p0, [U(i), V(j)], Rsum, 8.0);
        unsafe(i,j) = collide;
    end
end
figure('Color','w'); 
imagesc(U, V, flipud(unsafe.')); axis xy equal; grid on;
title('VO diagnostic at t=0 (yellow=true)'); xlabel('v_x [m/s]'); ylabel('v_y [m/s]');
exportgraphics(gcf, fullfile(OUT,"fig_vo_diagnostic.png"), 'Resolution',160);

disp(summary);

%% ========== helpers (local functions) ==========
function ok = in_lane(x, rright, rleft), ok = (x >= rright) && (x <= rleft); end
end % simulate_part1

% ---------- helper functions ----------
function val = crpf(xs, ys, xo, yo, v_obs, ax, ay, m_obs, size_obs, kappa_obs, G, zeta, eps, rho)
    rd = pseudo_distance(xs, ys, xo, yo, v_obs, eps, rho);
    if rd < 1e-6, rd = 1e-6; end
    M = virtual_mass(m_obs, v_obs);
    Tfac = type_factor(size_obs, kappa_obs);
    phi = accel_factor(ax, ay, xs, ys, xo, yo);
    val = G * M * Tfac * 1.0 * phi / (rd^zeta);
end

function rd = pseudo_distance(xs, ys, xo, yo, v_obs, eps, rho)
    dx = xs - xo; dy = ys - yo;
    termx = sign(dx) * (abs(dx)^eps) * exp(-rho*max(v_obs,0.0));
    termy = sign(dy) * (abs(dy)^eps);
    rd = hypot(termx, termy);
end

function phi = accel_factor(ax, ay, xs, ys, xo, yo)
    K = 1.0;
    a = [ax, ay]; rd = [xs-xo, ys-yo];
    na = norm(a); nr = norm(rd);
    if na < 1e-9 || nr < 1e-9, phi = 1.0; return; end
    cos_t = dot(a/na, rd/nr);
    denom = max(min(K - na*cos_t, 10.0), 0.2);
    phi = K / denom;
end

function M = virtual_mass(m, v)
    M = m * (1.566e-14 * (max(v,0.0)^6.687) + 0.3354);
end

function Tfac = type_factor(size, kappa)
    size_star = 4.0; kappa_star = 1.0; w1=1.0; w2=1.0;
    Tfac = (size / max(size_star,1e-6)) * (kappa / max(kappa_star,1e-6)) * w1*w2;
end

function [collide, ttc] = will_collide(p_rel, v_rel, R, horizon)
    v2 = dot(v_rel, v_rel);
    if v2 < 1e-12
        collide = (norm(p_rel) <= R); ttc = inf; return
    end
    tstar = -dot(p_rel, v_rel)/v2; tstar = min(max(tstar,0.0), horizon);
    dmin = norm(p_rel + tstar*v_rel);
    ttc = inf;
    if dot(p_rel, v_rel) < 0
        a=v2; b=2*dot(p_rel, v_rel); c=dot(p_rel,p_rel)-R^2;
        disc = b*b - 4*a*c;
        if disc >= 0
            r1 = (-b - sqrt(disc))/(2*a); r2 = (-b + sqrt(disc))/(2*a);
            roots = [r1,r2]; roots = roots(roots >= 0);
            if ~isempty(roots), ttc = min(roots); end
        end
    end
    collide = (dmin <= R);
end
